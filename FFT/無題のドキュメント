#ifndef FINANCE_DAYCOUNTFRACTION_H_INCLUDED
#define FINANCE_DAYCOUNTFRACTION_H_INCLUDED

#include <boost/date_time/gregorian/gregorian_types.hpp>

namespace finance {
    typedef boost::gregorian::date date_type;

    double dayCountAct365(const date_type& startDate,
            const date_type& endDate);
} // namespace finance

#endif // FINANCE_DAYCOUNTFRACTION_H_INCLUDED

#include "DayCountFraction.h"

namespace finance {
    typedef boost::gregorian::date date_type;

    double dayCountAct365(const date_type& startDate,
        const date_type& endDate)
    {
        return (endDate - startDate).days() / 365.0;
    }
} // namespace finance

#ifndef FINANCE_IOPTION_H_INCLUDED
#define FINANCE_IOPTION_H_INCLUDED

#include <boost/date_time/gregorian/gregorian_types.hpp>
#include <boost/shared_ptr.hpp>
#include "IPayoff.h"

namespace finance {
    typedef boost::gregorian::date date_type;

    class IOption {
    public:
        virtual ~IOption() {}

        double payoff(const double underlying) const
        {
            return doPayoff(underlying);
        }

        date_type expiryDate() const
        {
            return doExpiryDate();
        }

        boost::shared_ptr<IOption> clone() const
        {
            return boost::shared_ptr<IOption>(doClone());
        }

    private:
        virtual double doPayoff(double underlying) const = 0;

        virtual date_type doExpiryDate() const = 0;

        virtual IOption* doClone() const = 0;
    };

    class EuropeanOption : public IOption {
    public:
        EuropeanOption(const IPayoff& payoff, const date_type expiryDate) 
        : _ptrPayoff(payoff.clone()), _expiryDate(expiryDate)
        {
        }

        virtual ~EuropeanOption() {}

        boost::shared_ptr<EuropeanOption> clone() const
        {
            return boost::shared_ptr<EuropeanOption>(doClone());
        }

    private:
        virtual double doPayoff(double underlying) const
        {
            return (*_ptrPayoff)(underlying);
        }

        virtual date_type doExpiryDate() const 
        {
            return _expiryDate;
        }

        virtual EuropeanOption* doClone() const
        {
            return new EuropeanOption(*this);
        }

        const boost::shared_ptr<IPayoff> _ptrPayoff;
        const date_type _expiryDate;
    };

} // namespace finance

#endif // FINANCE_IOPTION_H_INCLUDED

#ifndef IPAYOFF_H_INCLUDED
#define IPAYOFF_H_INCLUDED

#include <boost/date_time/gregorian/gregorian_types.hpp>
#include <boost/shared_ptr.hpp>

namespace finance {
    typedef boost::gregorian::date date_type;

    class IPayoff {
    public:
        virtual ~IPayoff() {} 

        double operator()(double underlying) const
        {
            return doOperator(underlying);
        }

        boost::shared_ptr<IPayoff> clone() const
        {
            return boost::shared_ptr<IPayoff>(doClone());
        }

    private:
        virtual double doOperator(double underlying) const = 0;

        virtual IPayoff* doClone() const = 0;
    };

    class CallPayoff : public IPayoff {
    public:
        CallPayoff(const double strike) : _strike(strike)
        {
        }

        virtual ~CallPayoff() {} 

        boost::shared_ptr<CallPayoff> clone() const
        {
            return boost::shared_ptr<CallPayoff>(doClone());
        }

    private:
        virtual double doOperator(double underlying) const
        {
            return std::max(underlying - _strike, 0.0);
        }

        virtual CallPayoff* doClone() const 
        {
            return new CallPayoff(*this);
        }

        const double _strike;
    };

} // namespace finance

#endif // IPAYOFF_H_INCLUDED

#ifndef FINANCE_ISHORTRATE_H_INCLUDED
#define FINANCE_ISHORTRATE_H_INCLUDED

#include <boost/date_time/gregorian/gregorian_types.hpp>
#include <boost/shared_ptr.hpp>

namespace finance {
    typedef boost::gregorian::date date_type;

    class IShortRate {
    public:
        virtual ~IShortRate() {}

        double operator()(const date_type date) const
        {
            return doOperator(date);
        }
        
        boost::shared_ptr<IShortRate> clone() const
        {
            return boost::shared_ptr<IShortRate>(doClone());
        }

    private:
        virtual double doOperator(const date_type date) const = 0;

        virtual IShortRate* doClone() const = 0;
    };

    class ConstantShortRate : public IShortRate {
    public:
        ConstantShortRate(const double rate) : _rate(rate)
        {
        }

        virtual ~ConstantShortRate() {}

        boost::shared_ptr<ConstantShortRate> clone() const
        {
            return boost::shared_ptr<ConstantShortRate>(doClone());
        }

    private:
        virtual double doOperator(const date_type date) const
        {
            return _rate;
        }

        virtual ConstantShortRate* doClone() const
        {
            return new ConstantShortRate(*this);
        }
        
        const double _rate;
    };
} // namespace finance

#endif // FINANCE_ISHORTRATE_H_INCLUDED

#ifndef FINANCE_IMODEL_H_INCLUDED
#define FINANCE_IMODEL_H_INCLUDED

#include <complex>
#include <cmath>
#include <boost/date_time/gregorian/gregorian_types.hpp>
#include "DayCountFraction.h"

namespace finance {
    typedef boost::gregorian::date date_type;

    class IModel {
    public:
        virtual ~IModel() {}

        std::complex<double> calcCharacteristicFunction(
            const std::complex<double>& wave,
            const date_type& startDate, const date_type& endDate)
        {
            return doCalcCharacteristicFunction(wave, startDate, endDate);
        } 

        boost::shared_ptr<IModel> clone() const
        {
            return boost::shared_ptr<IModel>(doClone());
        }

    private:
        virtual std::complex<double> doCalcCharacteristicFunction(
            const std::complex<double>& wave,
            const date_type& startDate, const date_type& endDate) const = 0;

        virtual IModel* doClone() const = 0;

    };

    class BSModel : public IModel {
    public:
        BSModel(const double mu, const double sigma)
        : _mu(mu), _sigma(sigma)
        {
        }

        virtual ~BSModel() {}

        boost::shared_ptr<BSModel> clone() const
        {
            return boost::shared_ptr<BSModel>(doClone());
        }

    private:
        virtual std::complex<double> doCalcCharacteristicFunction(
            const std::complex<double>& wave,
            const date_type& startDate, const date_type& endDate) const
        {
            using namespace std::complex_literals;
            const double dcf = dayCountAct365(startDate, endDate);
            return std::exp(1.0i 
                    * wave * _mu * dcf 
                - 0.5 * _sigma * _sigma * wave * wave * dcf);
        }

        virtual BSModel* doClone() const { 
            return new BSModel(*this);
        }

        const double _mu;
        const double _sigma;
    };
} // namespace finance

#endif // FINANCE_IMODEL_H_INCLUDED
